<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Slit-Scan S-Ribbon (Correct Texture Orientation)</title>
  <style>
    html, body { margin: 0; overflow: hidden; }
    canvas#slitCanvas { display: none; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <canvas id="slitCanvas"></canvas>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const slitCanvas = document.getElementById('slitCanvas');
    const slitCtx = slitCanvas.getContext('2d');

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    function createSShapeCurve() {
      const curve = new THREE.Curve();
      curve.getPoint = function (t) {
        const x = (t - 0.5) * 10;
        const y = Math.sin(t * Math.PI * 2) * 2;
        const z = Math.sin(t * Math.PI) * 1;
        return new THREE.Vector3(x, y, z);
      };
      curve.getTangent = function (t) {
        const delta = 0.001;
        const p1 = this.getPoint(Math.max(t - delta, 0));
        const p2 = this.getPoint(Math.min(t + delta, 1));
        return p2.clone().sub(p1).normalize();
      };
      return curve;
    }

    function createRibbonFromCurve(curve, segments = 300, width = 1) {
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const uvs = [];
      const indices = [];

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const point = curve.getPoint(t);
        const tangent = curve.getTangent(t).normalize();

        const normal = new THREE.Vector3(0, 0, 1).cross(tangent).normalize();
        const left = point.clone().addScaledVector(normal, -width / 2);
        const right = point.clone().addScaledVector(normal, width / 2);

        positions.push(left.x, left.y, left.z);
        positions.push(right.x, right.y, right.z);

        // âœ… Swap UV axes so slitCanvas.height maps along ribbon length
        uvs.push(0, t);
        uvs.push(1, t);

        if (i < segments) {
          const base = i * 2;
          indices.push(base, base + 1, base + 2);
          indices.push(base + 1, base + 3, base + 2);
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      return geometry;
    }

    const tryResolutions = async () => {
      const baseConstraints = { facingMode: { ideal: "environment" } };
      const resolutions = [
        { width: 160, height: 120 },
        { width: 320, height: 240 },
        { width: 640, height: 480 }
      ];
      for (const res of resolutions) {
        try {
          return await navigator.mediaDevices.getUserMedia({
            video: {
              ...baseConstraints,
              width: { exact: res.width },
              height: { exact: res.height }
            }
          });
        } catch {}
      }
      return navigator.mediaDevices.getUserMedia({ video: baseConstraints });
    };

    const startSlitScan = async () => {
      const stream = await tryResolutions();
      const track = stream.getVideoTracks()[0];
      const processor = new MediaStreamTrackProcessor({ track });
      const reader = processor.readable.getReader();

      const { value: firstFrame } = await reader.read();
      const videoWidth = firstFrame.displayWidth;
      const videoHeight = firstFrame.displayHeight;

      slitCanvas.width = videoWidth;
      slitCanvas.height = 512; // Scrolls over time vertically
      let row = 0;

      const processFrame = async (frame) => {
        const bitmap = await createImageBitmap(frame);
        const tmp = new OffscreenCanvas(videoWidth, videoHeight);
        const tmpCtx = tmp.getContext('2d');
        tmpCtx.drawImage(bitmap, 0, 0);
        const midY = Math.floor(videoHeight / 2);
        const imageData = tmpCtx.getImageData(0, midY, videoWidth, 1);
        slitCtx.putImageData(imageData, 0, row);
        frame.close();
        row = (row + 1) % slitCanvas.height;
      };

      await processFrame(firstFrame);

      const slitTexture = new THREE.CanvasTexture(slitCanvas);
      slitTexture.wrapS = THREE.RepeatWrapping;
      slitTexture.wrapT = THREE.RepeatWrapping;
      slitTexture.minFilter = THREE.LinearFilter;

      // Optional: rotate texture so newest scanline is at start
      slitTexture.center.set(0.5, 0.5);
      slitTexture.rotation = Math.PI;

      const sCurve = createSShapeCurve();
      const ribbonGeometry = createRibbonFromCurve(sCurve, 300, 1);

      const ribbon = new THREE.Mesh(
        ribbonGeometry,
        new THREE.MeshBasicMaterial({ map: slitTexture, side: THREE.DoubleSide })
      );
      scene.add(ribbon);

      const renderLoop = () => {
        requestAnimationFrame(renderLoop);
        controls.update();
        renderer.render(scene, camera);
      };

      const animateSlit = async () => {
        while (true) {
          const { done, value: frame } = await reader.read();
          if (done) break;
          await processFrame(frame);
          slitTexture.needsUpdate = true;
        }
      };

      renderLoop();
      animateSlit();
    };

    startSlitScan();
  </script>
</body>
</html>
